// MSAA Resolve Implementation for RenderCommandEncoder::endEncoding()
// Insert this code at the beginning of the endEncoding() method, before the existing code

// MSAA Resolve: If framebuffer has resolve attachments, resolve MSAA to non-MSAA textures
if (framebuffer_) {
  const auto indices = framebuffer_->getColorAttachmentIndices();
  for (size_t i : indices) {
    auto msaaAttachment = std::static_pointer_cast<Texture>(framebuffer_->getColorAttachment(i));
    auto resolveAttachment = std::static_pointer_cast<Texture>(framebuffer_->getResolveColorAttachment(i));

    // Check if both MSAA source and resolve target exist
    if (msaaAttachment && resolveAttachment &&
        msaaAttachment->getResource() && resolveAttachment->getResource()) {

      // Verify MSAA source has samples > 1
      D3D12_RESOURCE_DESC msaaDesc = msaaAttachment->getResource()->GetDesc();
      D3D12_RESOURCE_DESC resolveDesc = resolveAttachment->getResource()->GetDesc();

      if (msaaDesc.SampleDesc.Count > 1 && resolveDesc.SampleDesc.Count == 1) {
        IGL_LOG_INFO("RenderCommandEncoder::endEncoding - Resolving MSAA attachment %zu (%u samples -> 1 sample)\n",
                     i, msaaDesc.SampleDesc.Count);

        // Transition MSAA texture to RESOLVE_SOURCE
        msaaAttachment->transitionAll(commandList_, D3D12_RESOURCE_STATE_RESOLVE_SOURCE);

        // Transition resolve texture to RESOLVE_DEST
        resolveAttachment->transitionAll(commandList_, D3D12_RESOURCE_STATE_RESOLVE_DEST);

        // Perform resolve operation using ID3D12GraphicsCommandList::ResolveSubresource
        // ResolveSubresource copies and converts MSAA texture to non-MSAA texture
        commandList_->ResolveSubresource(
            resolveAttachment->getResource(),  // pDstResource
            0,                                  // DstSubresource (mip 0, layer 0)
            msaaAttachment->getResource(),      // pSrcResource
            0,                                  // SrcSubresource (mip 0, layer 0)
            msaaDesc.Format                     // Format (must match both resources)
        );

        IGL_LOG_INFO("RenderCommandEncoder::endEncoding - MSAA resolve completed for attachment %zu\n", i);

        // Transition resolve texture to PIXEL_SHADER_RESOURCE for subsequent sampling
        resolveAttachment->transitionAll(commandList_, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
      }
    }
  }

  // Also handle depth resolve if present
  auto msaaDepth = std::static_pointer_cast<Texture>(framebuffer_->getDepthAttachment());
  auto resolveDepth = std::static_pointer_cast<Texture>(framebuffer_->getResolveDepthAttachment());

  if (msaaDepth && resolveDepth &&
      msaaDepth->getResource() && resolveDepth->getResource()) {

    D3D12_RESOURCE_DESC msaaDesc = msaaDepth->getResource()->GetDesc();
    D3D12_RESOURCE_DESC resolveDesc = resolveDepth->getResource()->GetDesc();

    if (msaaDesc.SampleDesc.Count > 1 && resolveDesc.SampleDesc.Count == 1) {
      IGL_LOG_INFO("RenderCommandEncoder::endEncoding - Resolving MSAA depth attachment (%u samples -> 1 sample)\n",
                   msaaDesc.SampleDesc.Count);

      msaaDepth->transitionAll(commandList_, D3D12_RESOURCE_STATE_RESOLVE_SOURCE);
      resolveDepth->transitionAll(commandList_, D3D12_RESOURCE_STATE_RESOLVE_DEST);

      commandList_->ResolveSubresource(
          resolveDepth->getResource(),
          0,
          msaaDepth->getResource(),
          0,
          msaaDesc.Format
      );

      IGL_LOG_INFO("RenderCommandEncoder::endEncoding - MSAA depth resolve completed\n");
      resolveDepth->transitionAll(commandList_, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
    }
  }
}
